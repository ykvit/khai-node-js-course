{"version":3,"sources":["../../src/gel-core/session.ts"],"sourcesContent":["import { entityKind } from '~/entity.ts';\nimport { TransactionRollbackError } from '~/errors.ts';\nimport type { TablesRelationalConfig } from '~/relations.ts';\nimport type { PreparedQuery } from '~/session.ts';\nimport type { Query, SQL } from '~/sql/index.ts';\nimport { tracer } from '~/tracing.ts';\nimport type { NeonAuthToken } from '~/utils.ts';\nimport { GelDatabase } from './db.ts';\nimport type { GelDialect } from './dialect.ts';\nimport type { SelectedFieldsOrdered } from './query-builders/select.types.ts';\n\nexport interface PreparedQueryConfig {\n\texecute: unknown;\n\tall: unknown;\n\tvalues: unknown;\n}\n\nexport abstract class GelPreparedQuery<T extends PreparedQueryConfig> implements PreparedQuery {\n\tconstructor(protected query: Query) {}\n\n\tprotected authToken?: NeonAuthToken;\n\n\tgetQuery(): Query {\n\t\treturn this.query;\n\t}\n\n\tmapResult(response: unknown, _isFromBatch?: boolean): unknown {\n\t\treturn response;\n\t}\n\n\tstatic readonly [entityKind]: string = 'GelPreparedQuery';\n\n\t/** @internal */\n\tjoinsNotNullableMap?: Record<string, boolean>;\n\n\tabstract execute(placeholderValues?: Record<string, unknown>): Promise<T['execute']>;\n\n\t/** @internal */\n\tabstract all(placeholderValues?: Record<string, unknown>): Promise<T['all']>;\n\n\t/** @internal */\n\tabstract isResponseInArrayMode(): boolean;\n}\n\nexport abstract class GelSession<\n\tTQueryResult extends GelQueryResultHKT = any, // TO\n\tTFullSchema extends Record<string, unknown> = Record<string, never>,\n\tTSchema extends TablesRelationalConfig = Record<string, never>,\n> {\n\tstatic readonly [entityKind]: string = 'GelSession';\n\n\tconstructor(protected dialect: GelDialect) {}\n\n\tabstract prepareQuery<T extends PreparedQueryConfig = PreparedQueryConfig>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\tname: string | undefined,\n\t\tisResponseInArrayMode: boolean,\n\t\tcustomResultMapper?: (rows: unknown[][], mapColumnValue?: (value: unknown) => unknown) => T['execute'],\n\t): GelPreparedQuery<T>;\n\n\texecute<T>(query: SQL): Promise<T> {\n\t\treturn tracer.startActiveSpan('drizzle.operation', () => {\n\t\t\tconst prepared = tracer.startActiveSpan('drizzle.prepareQuery', () => {\n\t\t\t\treturn this.prepareQuery<PreparedQueryConfig & { execute: T }>(\n\t\t\t\t\tthis.dialect.sqlToQuery(query),\n\t\t\t\t\tundefined,\n\t\t\t\t\tundefined,\n\t\t\t\t\tfalse,\n\t\t\t\t);\n\t\t\t});\n\n\t\t\treturn prepared.execute(undefined);\n\t\t});\n\t}\n\n\tall<T = unknown>(query: SQL): Promise<T[]> {\n\t\treturn this.prepareQuery<PreparedQueryConfig & { all: T[] }>(\n\t\t\tthis.dialect.sqlToQuery(query),\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tfalse,\n\t\t).all();\n\t}\n\n\tasync count(sql: SQL): Promise<number> {\n\t\tconst res = await this.execute<[{ count: string }]>(sql);\n\n\t\treturn Number(\n\t\t\tres[0]['count'],\n\t\t);\n\t}\n\n\tabstract transaction<T>(\n\t\ttransaction: (tx: GelTransaction<TQueryResult, TFullSchema, TSchema>) => Promise<T>,\n\t): Promise<T>;\n}\n\nexport abstract class GelTransaction<\n\tTQueryResult extends GelQueryResultHKT,\n\tTFullSchema extends Record<string, unknown> = Record<string, never>,\n\tTSchema extends TablesRelationalConfig = Record<string, never>,\n> extends GelDatabase<TQueryResult, TFullSchema, TSchema> {\n\tstatic override readonly [entityKind]: string = 'GelTransaction';\n\n\tconstructor(\n\t\tdialect: GelDialect,\n\t\tsession: GelSession<any, any, any>,\n\t\tprotected schema: {\n\t\t\tfullSchema: Record<string, unknown>;\n\t\t\tschema: TSchema;\n\t\t\ttableNamesMap: Record<string, string>;\n\t\t} | undefined,\n\t) {\n\t\tsuper(dialect, session, schema);\n\t}\n\n\trollback(): never {\n\t\tthrow new TransactionRollbackError();\n\t}\n\n\tabstract override transaction<T>(\n\t\ttransaction: (tx: GelTransaction<TQueryResult, TFullSchema, TSchema>) => Promise<T>,\n\t): Promise<T>;\n}\n\nexport interface GelQueryResultHKT {\n\treadonly $brand: 'GelQueryResultHKT';\n\treadonly row: unknown;\n\treadonly type: unknown;\n}\n\nexport type GelQueryResultKind<TKind extends GelQueryResultHKT, TRow> = (TKind & {\n\treadonly row: TRow;\n})['type'];\n"],"mappings":"AAAA,SAAS,kBAAkB;AAC3B,SAAS,gCAAgC;AAIzC,SAAS,cAAc;AAEvB,SAAS,mBAAmB;AAUrB,MAAe,iBAAyE;AAAA,EAC9F,YAAsB,OAAc;AAAd;AAAA,EAAe;AAAA,EAE3B;AAAA,EAEV,WAAkB;AACjB,WAAO,KAAK;AAAA,EACb;AAAA,EAEA,UAAU,UAAmB,cAAiC;AAC7D,WAAO;AAAA,EACR;AAAA,EAEA,QAAiB,UAAU,IAAY;AAAA;AAAA,EAGvC;AASD;AAEO,MAAe,WAIpB;AAAA,EAGD,YAAsB,SAAqB;AAArB;AAAA,EAAsB;AAAA,EAF5C,QAAiB,UAAU,IAAY;AAAA,EAYvC,QAAW,OAAwB;AAClC,WAAO,OAAO,gBAAgB,qBAAqB,MAAM;AACxD,YAAM,WAAW,OAAO,gBAAgB,wBAAwB,MAAM;AACrE,eAAO,KAAK;AAAA,UACX,KAAK,QAAQ,WAAW,KAAK;AAAA,UAC7B;AAAA,UACA;AAAA,UACA;AAAA,QACD;AAAA,MACD,CAAC;AAED,aAAO,SAAS,QAAQ,MAAS;AAAA,IAClC,CAAC;AAAA,EACF;AAAA,EAEA,IAAiB,OAA0B;AAC1C,WAAO,KAAK;AAAA,MACX,KAAK,QAAQ,WAAW,KAAK;AAAA,MAC7B;AAAA,MACA;AAAA,MACA;AAAA,IACD,EAAE,IAAI;AAAA,EACP;AAAA,EAEA,MAAM,MAAM,KAA2B;AACtC,UAAM,MAAM,MAAM,KAAK,QAA6B,GAAG;AAEvD,WAAO;AAAA,MACN,IAAI,CAAC,EAAE,OAAO;AAAA,IACf;AAAA,EACD;AAKD;AAEO,MAAe,uBAIZ,YAAgD;AAAA,EAGzD,YACC,SACA,SACU,QAKT;AACD,UAAM,SAAS,SAAS,MAAM;AANpB;AAAA,EAOX;AAAA,EAZA,QAA0B,UAAU,IAAY;AAAA,EAchD,WAAkB;AACjB,UAAM,IAAI,yBAAyB;AAAA,EACpC;AAKD;","names":[]}